# C++ Primer学习笔记之拷贝控制
时间：2019年6月26日

<br/><br/>
# 1 拷贝、赋值与销毁
## 1.1 拷贝构造函数
**拷贝构造函数**：如果一个构造函数的第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。   
```
class Foo{
public:
	Foo();				// 默认构造函数
	Foo(const Foo&); 	// 拷贝构造函数
	// ...
}；
```
### 合成拷贝构造函数  
如果我们没有为一个类定义拷贝构造函数，则编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他的构造函数，编译器也会为我们合成一个拷贝构造函数。

### 拷贝初始化
当使用**直接初始化**时，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；当使用**拷贝初始化**时，要求编译器将右侧对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。
```
string dots(10, '.');		// 直接初始化
string s(dots);			// 直接初始化
string s2 = dots;		// 拷贝初始化
string null_book = "9-999-99999-9";		// 拷贝初始化
string nines = string(100, '9');		// “=”为拷贝初始化，后面为直接初始化
```  

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况也会发生：
+ 将一个对象作为实参传递给一个非引用类型的形参
+ 从一个返回类型为非引用类型的函数返回一个对象
+ 用花括号列表初始化一个数组中的元素或一个聚合类中的成员  
  
<br/><br/>
## 1.2 拷贝赋值运算符
与类控制器对象如何初始化一样，类也可以控制其对象如何赋值：
```
Sales_data trans, accum;
trans = accum; 		// 使用Sales_data的拷贝赋值运算符
```
### 重载赋值运算符
**拷贝赋值运算符**接受一个与其所在类相同类型的参数，通常返回一个指向其左侧运算对象的引用。
```
class Foo{
public:
	Foo& operator=(const Foo&);		// 赋值运算符
	// ...
}；
```

### 合成拷贝赋值运算符
如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**。  

<br/><br/>
## 1.3 析构函数
析构函数执行与苟傲函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。
```
class Foo{
public:
	~Foo();		// 析构函数
	// ...
}；
```  
析构函数不接受参数，无法重载。

### 析构函数完成什么工作
在对象最后一次使用后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

### 什么时候会调用析构函数
无论何时一个对象被销毁，就会自动调用其析构函数：
+ 变量在离开其作用域是被销毁
+ 当一个对象被销毁时，其成员被销毁
+ 容器被销毁时，其元素被销毁
+ 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
+ 对于临时对象，当创建它的完整表达式结束时被销毁  

**注：** 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

### 合成析构函数
当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。

<br/><br/>
## 1.4 三/五法则
当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求比对拷贝构造函数或赋值运算符的需求更为明显。如果某个类需要一个析构函数，那么几乎可以确定它也需要一个拷贝构造函数和一个拷贝赋值运算符。  

如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。

<br/><br/>
## 1.5 使用=default
我们可以通过将拷贝控制成员定义为**=default**来显示地要求编译器生成合成的版本，此时合成的函数隐式地声明为**内联**的。如果内联不是我们希望的，则应只对成员的类外定义使用**=default**。  

```
class Sales_data{
public:
	// 拷贝控制成员
	Sales_data() = default; 	// 内联
	Sales_data(const Sales_data&) = default;
	Sales_data& operator=(const Sales_data&);
	~Sales_data() = default;
	...
};
Sales_data& operator(const Sales_data&) = default; // 非内联
```  

<br/><br/>
## 1.6 阻止拷贝
对于某些类而言，拷贝构造函数和拷贝赋值运算符时没有合理意义的。如：iostream类阻止了拷贝，以避免对个对象写入或读取相同的IO缓冲。

### 定义删除的函数
在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝。删除函数这样一种函数：我们虽然定义了它们，却不能以任何方式使用它们。在函数的参数列表后面加上=delete来指示我们希望将它定义为删除的：  
```
struct NoCopy{
	NoCopy() = default;
	NoCopy(const NoCopy&) = delete;		// 阻止拷贝
	NoCopy& operator(const NoCopy&) = delete; 		// 阻止赋值
	~NoCopy() = defalult;
	...
};
```  
与=default不同，=delete必须出现在函数第一次声明的时候。

### 合成的拷贝控制成员可能是删除的
对于某些类而言，如果其中的数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。

### private拷贝控制
在新版本之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝：
```
class PrivateCopy{
	PrivateCopy(const PrivateCopy&);
	PrivateCopy& operator=(const PrivateCopy&);
public:
	PrivateCopy() = default;
	~PrivateCopy();
};
```

<br/><br/>
# 2 拷贝控制和资源管理
通常，管理类外资源的类必须定义拷贝控制成员。为了定义这些成员，首先必须明确此类型对象的拷贝语义。一般有两种选择：使类的行为看起来像一个值或像一个指针。  

类的行为像值，意味着它应该有自己的状态。当我们拷贝一个像值的对象时，副本和原对象应该是完全独立的。

行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。

## 2.1 行为像值的类
以HasPtr为例，HasPtr需要
+ 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
+ 定义一个析构函数来释放string
+ 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string

```
class HasPtr{
public:
    HasPtr(const std::string &s = std::string()):
        ps(new std::string(s), i(0)) { }
    HasPtr(const HasPtr &p):
        ps(new std::string(*p.ps)), i(p.i) { }
        
}
```