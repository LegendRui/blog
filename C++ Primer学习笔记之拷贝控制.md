<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

# C++ Primer学习笔记之拷贝控制
时间：2019年6月26日

<br/><br/>
# 1 拷贝、赋值与销毁
## 1.1 拷贝构造函数
**拷贝构造函数**：如果一个构造函数的第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。   
```
class Foo{
public:
	Foo();				// 默认构造函数
	Foo(const Foo&); 	// 拷贝构造函数
	// ...
}；
```
### 合成拷贝构造函数  
如果我们没有为一个类定义拷贝构造函数，则编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他的构造函数，编译器也会为我们合成一个拷贝构造函数。

### 拷贝初始化
当使用**直接初始化**时，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；当使用**拷贝初始化**时，要求编译器将右侧对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。
```
string dots(10, '.');		// 直接初始化
string s(dots);			// 直接初始化
string s2 = dots;		// 拷贝初始化
string null_book = "9-999-99999-9";		// 拷贝初始化
string nines = string(100, '9');		// “=”为拷贝初始化，后面为直接初始化
```  

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况也会发生：
+ 将一个对象作为实参传递给一个非引用类型的形参
+ 从一个返回类型为非引用类型的函数返回一个对象
+ 用花括号列表初始化一个数组中的元素或一个聚合类中的成员  
  
<br/><br/>
## 1.2 拷贝赋值运算符
与类控制器对象如何初始化一样，类也可以控制其对象如何赋值：
```
Sales_data trans, accum;
trans = accum; 		// 使用Sales_data的拷贝赋值运算符
```
### 重载赋值运算符
**拷贝赋值运算符**接受一个与其所在类相同类型的参数，通常返回一个指向其左侧运算对象的引用。
```
class Foo{
public:
	Foo& operator=(const Foo&);		// 赋值运算符
	// ...
}；
```

### 合成拷贝赋值运算符
如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**。  

<br/><br/>
## 1.3 析构函数
析构函数执行与苟傲函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。
```
class Foo{
public:
	~Foo();		// 析构函数
	// ...
}；
```  
析构函数不接受参数，无法重载。

### 析构函数完成什么工作
在对象最后一次使用后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

### 什么时候会调用析构函数
无论何时一个对象被销毁，就会自动调用其析构函数：
+ 变量在离开其作用域是被销毁
+ 当一个对象被销毁时，其成员被销毁
+ 容器被销毁时，其元素被销毁
+ 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
+ 对于临时对象，当创建它的完整表达式结束时被销毁  

**注：** 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

$F = \frac{1}{2}mv^2$