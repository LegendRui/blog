# 计算机网络

[toc]

##  http与https
http: 是一个基于TCP协议的客户端和服务器端请求和应答的标准，用于从 WWW 服务器传输超文本到本地浏览器。

https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输的安全。

## http 和 https 的区别及优缺点？
1. http信息是明文传输的，而https协议在此基础上添加了SSL加密，因此https比http更安全，可以防止数据在传输过程中被窃取和改变，确保数据的真实性；
2. http的默认端口是80，而https的默认端口是443；
3. http的连接是无状态的，而https是在HHTP的基础上加上了SSL，可以进行信息加密与身份认证，但这会在握手阶段带来额外的开销；
4. https的缓存不如http高效，因此会增加数据开销；
5. https需要ca证书，而ca证书比较昂贵。

##  https通信的步骤
1. 客户端与服务器建立SSL连接；
2. 服务器将CA证书发送给客户端；
3. 双方协商加密等级；
4. 客户端使用协商一致的等级建立会话密钥，然后通过网站的公钥加密会话，并发送到服务器；
5. 服务器通过私钥解密；
6. 服务器通过密钥加密与客户端的通信。

##  TCP3次握手
1. 客户端发送`SYN`给服务器，其中携带自己的同步序列号`x`；
2. 服务器收到客户端的`SYN`后也发送一个`SYN`给客户端，其中携带`ACK`(ack=i+1)以及自己的同步序列号`y`,此时服务器进入`SYN_RECV`状态；
3. 客户端收到客户返回的`SYN`及`ACK`，确认`ACK`正确（是x+1）后也发送一个`ACK`（ack=y+1）给服务器，客户端发送了这个包后进入`ESTABLISHED`状态，而服务器收到`ACK`后也进入`ESTABLISHED`状态。注意，在这1次，客户端是**可以携带数据**的。

![](https://segmentfault.com/img/remote/1460000039165594)

## 为什么需要3次握手
1. 如果只有1次，客户端不知道服务器是否能收到自己的请求；
2. 如果只有2次，服务器发送了确认报文就进入连接状态的话，服务器不知道自己的确认报文客户端能否收到。如果客户端没有收到，那么客户端就不会发送数据，而服务器一直在等待，浪费资源。

##  4次挥手
1. 客户端发送释放报文给服务器，并停止向服务器发数据。在释放报文的头部,`FIN`为1，同时携带自己的同步序列号`u`，此时客户端进入`FIN-WAIT-1`状态；
2. 服务器收到释放报文后，发送确认报文。在确认报文中，`ACK`为1，ack=u+1并携带了自己的同步序列号`v`，服务器进入了`CLOSE-WAIT`状态。此时服务器通知应用层客户端请求释放了，但是服务器还可以向客户端发送数据；
3. 客户端收到服务器的确认报文后，进入`FIN_WAIT-2`状态，等待服务器发送完数据（如果有）后发送释放报文;
4. 服务器发送完数据后发送释放报文并进入`LAST-ACK`状态。在释放报文中，FIN为1，ack=u+1，并携带自己的同步序列号w(因为中间可能还在向客户端发数据，序列号在增加)；
5. 客户端收到服务器发来的释放报文后，发送报文确认，此时客户端进入`TIME-WAIT`状态，等待2*MSL(最长报文段寿命)后真正释放连接。在确认报文中，ack=w+1，同步序列号v+1；
6. 服务器收到客户端的确认报文，立刻释放连接，进入`CLOSED`状态。

![](https://segmentfault.com/img/remote/1460000039165595)

##  为什么需要4次挥手？
1. 如果1次，客户端发送了请求就关闭。如果客户端没收到这条报文，会持续等待客户端发送数据；
2. 如果2次，服务器发送了确认报文就关闭，那么此时剩余的数据没法发送给客户端；
3. 如果3次且服务器发送了释放报文客户端没收到，那么客户端就会一直等待服务器发送释放报文。

##  为什么要等待2*MSL？
目的是确认服务器收到了客户端发送的释放确认报文。因为如果服务器没有收到释放确认报文，那么就会隔一段时间重发释放报文，在这段时间内客户端收到后就可以重新释放确认报文。

## 9. TCP如何确保数据发送的有序可靠？
1. 每次发送数据后，发送方都会将已发送的数据缓存下来；
2. 对于每个发送的数据包，发送方都会设置一个定时器；
3. 如果在定时器结束之前收到了数据包的响应（这个响应可能是本包，也可能是后面的包的），则从缓存中删除该数据包；
4. 否则，重传该数据包，直到收到应答或到达最大重传次数为止；
5. 接收方收到数据包会先进行CRC校验，校验通过才会进行后续处理，并将应答次数加1进行应答。

##  滑动窗口
在实际传输过程中，每次发送报文后都等待确认报文会极大地降低传输地效率。因此，TCP允许，连续发送n个包而无需等待确认报文。这个n就是窗口的大小。

##  TCP快速重传
如果在某次传输过程中：
- 发送方发送了SEQ#1，SEQ#2,SEQ#3,SEQ#4,SEQ#5
- 因为某些原因，接收方没有收到SEQ#2
- 那么对于SEQ#3/SEQ#4/SEQ#5，接收方发送的ACK序列号都是2
- 接收方发现ACK一直是2后，知道接收方没有收到SEQ#2，于是在重传定时器超时之前重发SEQ#2

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg)

##  TCP与UDP的区别
1. TCP是面向连接的，而UDP是无连接的；
2. TCP仅支持单播，而UDP支持单播，多播与广播；
3. TCP是可靠的，发送方会确认接收方是否收到数据，而UDP是不可靠的，不会确认接收方是否接受到数据；
4. UDP开销小，传输速率更高，实时性更好。

##  浏览器同源策略
浏览器的安全策略，如果协议，主机名或端口号任何一个不同，都会被浏览器认为是不同的域。

##  跨域的解决方法
1. JSONP
+ 借由HTML的script标签的src属性实现，缺点是支持get请求，而且需要后端配合

2. CORS
服务器设置`Access-Control-Allow-Origin` HTTP响应头

3. Proxy代理
配置代理服务器（如Vue的代理选项，Nginx等），主流解决方案

## Cookie，sessionStorage与localStorage的区别
1. Cookie中存储的数据在过期前一直有效，每次发送请求时都会携带给服务器，但是数据大小最大只有4k
2. localStorage可以永久存储在本地，且关闭窗口不会消失，最大可以存储5M+
3. sessionStorage存储数据在本地，关闭窗口就会消失，最大可以存储5M+

## 输入URL到页面加载的全过程
1. 查找缓存： 浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步
   + 查询浏览器缓存
   + 查询操作系统缓存
   + 查询路由缓存
   + 查询ISP缓存
2. 域名解析： 浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。（先向本地域名服务器递归查询，查过没查询到则迭代查询）
3. 建立TCP连接： 解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接
4. 发送HTTP/HTTPS请求： 浏览器发起读取文件的HTTP/HTTPS请求，该请求报文作为TCP三次握手的**第三次数据**发送给服务器
5. 服务器响应并返回: 服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
6. 关闭TCP连接: 服务器发送完数据后，通过四次挥手关闭连接
7. 浏览器渲染： 浏览器解析客户端发送回来到HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：
   + 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
   + 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
   + 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
   + 布局（Layout）：计算出每个节点在屏幕中的位置
   + 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点
8. 解析执行JS： 用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
   + 创建window对象
   + 加载
   + 预编译
   + 解释执行

## 重绘与重排
+ 重排/回流（Reflow）：当DOM的变化影响了元素的几何信息（尺寸、位置），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。
+ 重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。
## 如何触发重排和重绘？
任何改变用来构建渲染树的信息都会导致一次重排或重绘：

+ 添加、删除、更新DOM节点
+ 通过display: none隐藏一个DOM节点-触发重排和重绘
+ 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
+ 移动或者给页面中的DOM节点添加动画
+ 添加一个样式表，调整样式属性
+ 用户行为，例如调整窗口大小，改变字号，或者滚动。

## 如何避免重绘或者重排？
1. 集中改变样式，不要一条一条地修改 DOM 的样式。
2. 不要把 DOM 结点的属性值放在循环里当成循环里的变量。
3. 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
4. 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
5. 尽量只修改position：absolute或fixed元素，对其他元素影响不大。
6. 动画开始GPU加速，translate使用3D变化
7. 提升为合成层，将元素提升为合成层有以下优点：
   + 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
   + 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
   + 对于 transform 和 opacity 效果，不会触发 layout 和 paint

   **ps**: 提升合成层的最好方式是使用 CSS 的 will-change 属性：
```
#target {
  will-change: transform;
}
```



## 浏览器的缓存机制 强制缓存 & 协商缓存
浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
由上图我们可以知道：
+ 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
+ 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。


### 强制缓存
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中`Cache-Control`优先级比`Expires`高。
强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

+ 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
+ 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
+ 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

### 协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified` / `If-Modified-Since` 和 `Etag` / `If-None-Match`，其中`Etag` / `If-None-Match`的优先级比`Last-Modified` / `If-Modified-Since`高。协商缓存主要有以下两种情况：
+ 协商缓存生效，返回304
+ 协商缓存失效，返回200和请求结果结果

## 304过程

1. 浏览器请求资源时首先命中资源的`Expires` 和 `Cache-Control`，`Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过`Cache-control`: max-age指定最大生命周期. 强缓存状态码仍然是200，但不会请求数据，在浏览器中能明显看到from cache字样。
2. 强缓存失效，进入协商缓存阶段，首先验证ETag。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的`If-None-Match`值来判断是否命中缓存。
3. 协商缓存`Last-Modify`/`If-Modify-Since`阶段，客户端第一次请求资源时，服务服返回的header中会加上`Last-Modify`，`Last-modify`是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含`If-Modify-Since`，该值为缓存之前返回的`Last-Modify`。服务器收到`If-Modify-Since`后，根据资源的最后修改时间判断是否命中缓存。


## CSS 盒子模型
CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。
在标准的盒子模型中，width 指 content 部分的宽度。
在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。
故在计算盒子的宽度时存在差异：
+ 标准盒模型： 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)
+ 怪异盒模型： 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）

## box-sizing属性
box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box/border-box/inherit
+ content-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】
+ border-box：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】
+ inherit：继承父元素的 box-sizing 值。

## BFC（块级格式上下文）
### 概念
BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。

### 布局原理
+ 内部的Box会在垂直方向，一个接一个地放置
+ Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠
+ 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反
+ BFC的区域不会与float box重叠
+ BFC是一个独立容器，容器里面的子元素不会影响到外面的元素
+ 计算BFC的高度时，浮动元素也参与计算高度
+ 元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的Formatting Context。

### 创建方式
+ 根元素即HTML元素为BFC
+ float属性的值不为none
+ position属性的值为absolute或fixed
+ display属性的值为inline-block、table-cell、table-caption等
+ overflow的值不为visible

### 使用场景
- 去除边距重叠现象
- 清除浮动（让父元素的高度包含子浮动元素）
- 避免某元素被浮动元素覆盖
- 避免多列布局由于宽度计算四舍五入而自动换行

## 水平居中
+ 行内元素: text-align: center
+ 确定宽度的元素
    - margin: 0 auto
    - 绝对定位和margin-left: (父width - 子width）/2, 前提是父元素position: relative
+ 对于宽度未知的块级元素
    - table标签配合margin左右auto实现水平居中。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。
    - inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。
    - 绝对定位+transform，translateX可以移动本身元素的50%。
    - flex布局使用justify-content:center

