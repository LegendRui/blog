# 计算机网络

[toc]

##  http与https
http: 是一个基于TCP协议的客户端和服务器端请求和应答的标准，用于从 WWW 服务器传输超文本到本地浏览器。

https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输的安全。

## http 和 https 的区别及优缺点？
1. http信息是明文传输的，而https协议在此基础上添加了SSL加密，因此https比http更安全，可以防止数据在传输过程中被窃取和改变，确保数据的真实性；
2. http的默认端口是80，而https的默认端口是443；
3. http的连接是无状态的，而https是在HHTP的基础上加上了SSL，可以进行信息加密与身份认证，但这会在握手阶段带来额外的开销；
4. https的缓存不如http高效，因此会增加数据开销；
5. https需要ca证书，而ca证书比较昂贵。

##  https通信的步骤
1. 客户端与服务器建立SSL连接；
2. 服务器将CA证书发送给客户端；
3. 双方协商加密等级；
4. 客户端使用协商一致的等级建立会话密钥，然后通过网站的公钥加密会话，并发送到服务器；
5. 服务器通过私钥解密；
6. 服务器通过密钥加密与客户端的通信。

##  TCP3次握手
1. 客户端发送`SYN`给服务器，其中携带自己的同步序列号`x`；
2. 服务器收到客户端的`SYN`后也发送一个`SYN`给客户端，其中携带`ACK`(ack=i+1)以及自己的同步序列号`y`,此时服务器进入`SYN_RECV`状态；
3. 客户端收到客户返回的`SYN`及`ACK`，确认`ACK`正确（是x+1）后也发送一个`ACK`（ack=y+1）给服务器，客户端发送了这个包后进入`ESTABLISHED`状态，而服务器收到`ACK`后也进入`ESTABLISHED`状态。注意，在这1次，客户端是**可以携带数据**的。

![](https://segmentfault.com/img/remote/1460000039165594)

## 为什么需要3次握手
1. 如果只有1次，客户端不知道服务器是否能收到自己的请求；
2. 如果只有2次，服务器发送了确认报文就进入连接状态的话，服务器不知道自己的确认报文客户端能否收到。如果客户端没有收到，那么客户端就不会发送数据，而服务器一直在等待，浪费资源。

##  4次挥手
1. 客户端发送释放报文给服务器，并停止向服务器发数据。在释放报文的头部,`FIN`为1，同时携带自己的同步序列号`u`，此时客户端进入`FIN-WAIT-1`状态；
2. 服务器收到释放报文后，发送确认报文。在确认报文中，`ACK`为1，ack=u+1并携带了自己的同步序列号`v`，服务器进入了`CLOSE-WAIT`状态。此时服务器通知应用层客户端请求释放了，但是服务器还可以向客户端发送数据；
3. 客户端收到服务器的确认报文后，进入`FIN_WAIT-2`状态，等待服务器发送完数据（如果有）后发送释放报文;
4. 服务器发送完数据后发送释放报文并进入`LAST-ACK`状态。在释放报文中，FIN为1，ack=u+1，并携带自己的同步序列号w(因为中间可能还在向客户端发数据，序列号在增加)；
5. 客户端收到服务器发来的释放报文后，发送报文确认，此时客户端进入`TIME-WAIT`状态，等待2*MSL(最长报文段寿命)后真正释放连接。在确认报文中，ack=w+1，同步序列号v+1；
6. 服务器收到客户端的确认报文，立刻释放连接，进入`CLOSED`状态。

![](https://segmentfault.com/img/remote/1460000039165595)

##  为什么需要4次挥手？
1. 如果1次，客户端发送了请求就关闭。如果客户端没收到这条报文，会持续等待客户端发送数据；
2. 如果2次，服务器发送了确认报文就关闭，那么此时剩余的数据没法发送给客户端；
3. 如果3次且服务器发送了释放报文客户端没收到，那么客户端就会一直等待服务器发送释放报文。

##  为什么要等待2*MSL？
目的是确认服务器收到了客户端发送的释放确认报文。因为如果服务器没有收到释放确认报文，那么就会隔一段时间重发释放报文，在这段时间内客户端收到后就可以重新释放确认报文。

## 9. TCP如何确保数据发送的有序可靠？
1. 每次发送数据后，发送方都会将已发送的数据缓存下来；
2. 对于每个发送的数据包，发送方都会设置一个定时器；
3. 如果在定时器结束之前收到了数据包的响应（这个响应可能是本包，也可能是后面的包的），则从缓存中删除该数据包；
4. 否则，重传该数据包，直到收到应答或到达最大重传次数为止；
5. 接收方收到数据包会先进行CRC校验，校验通过才会进行后续处理，并将应答次数加1进行应答。

##  滑动窗口
在实际传输过程中，每次发送报文后都等待确认报文会极大地降低传输地效率。因此，TCP允许，连续发送n个包而无需等待确认报文。这个n就是窗口的大小。

##  TCP快速重传
如果在某次传输过程中：
- 发送方发送了SEQ#1，SEQ#2,SEQ#3,SEQ#4,SEQ#5
- 因为某些原因，接收方没有收到SEQ#2
- 那么对于SEQ#3/SEQ#4/SEQ#5，接收方发送的ACK序列号都是2
- 接收方发现ACK一直是2后，知道接收方没有收到SEQ#2，于是在重传定时器超时之前重发SEQ#2

![](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg)

##  TCP与UDP的区别
1. TCP是面向连接的，而UDP是无连接的；
2. TCP仅支持单播，而UDP支持单播，多播与广播；
3. TCP是可靠的，发送方会确认接收方是否收到数据，而UDP是不可靠的，不会确认接收方是否接受到数据；
4. UDP开销小，传输速率更高，实时性更好。

##  浏览器同源策略
浏览器的安全策略，如果协议，主机名或端口号任何一个不同，都会被浏览器认为是不同的域。

##  跨域的解决方法
1. JSONP
+ 借由HTML的script标签的src属性实现，缺点是支持get请求，而且需要后端配合

2. CORS
服务器设置`Access-Control-Allow-Origin` HTTP响应头

3. Proxy代理
配置代理服务器（如Vue的代理选项，Nginx等），主流解决方案

## Cookie，sessionStorage与localStorage的区别
1. Cookie中存储的数据在过期前一直有效，每次发送请求时都会携带给服务器，但是数据大小最大只有4k
2. localStorage可以永久存储在本地，且关闭窗口不会消失，最大可以存储5M+
3. sessionStorage存储数据在本地，关闭窗口就会消失，最大可以存储5M+

## 输入URL到页面加载的全过程
1. 查找缓存： 浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步
+ 查询浏览器缓存
+ 查询操作系统缓存
+ 查询路由缓存
+ 查询ISP缓存
2. 域名解析： 浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。（先向本地域名服务器递归查询，查过没查询到则迭代查询）
3. 建立TCP连接： 解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接
4. 发送HTTP/HTTPS请求： 浏览器发起读取文件的HTTP/HTTPS请求，该请求报文作为TCP三次握手的**第三次数据**发送给服务器
5. 服务器响应并返回: 服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
6. 关闭TCP连接: 服务器发送完数据后，通过四次挥手关闭连接
7. 浏览器渲染： 浏览器解析客户端发送回来到HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：
+ 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
+ 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
+ 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
+ 布局（Layout）：计算出每个节点在屏幕中的位置
+ 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点
8. 解析执行JS： 用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
+ 创建window对象
+ 加载
+ 预编译
+ 解释执行
