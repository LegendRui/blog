# 操作系统篇

## 进程与线程的区别
* 进程是系统资源分配的最小单位，线程是CPU调度的最小单位
* 进程有自己独立的地址空间，包括代码段，堆栈段和数据段；线程共享进程中的数据
* 进程创建、切换与撤销的代价很大，而线程相应的开销很小
* 线程通信方式很方便，而进程间通信要以IPC进行
* 一个进程挂掉，对其他进程没有影响，而一个线程挂掉，用一个进程下的其他线程都挂掉


## 进程间的通信方式
+ 临界区
    + 是一段独占对某些共享资源访问的代码，在任意时刻 **只允许一个线程** 对共享资源访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占
    + 接口：windows下，用EnterCriticalSection()函数标记临界区，用LeaveCriticalSection()函数释放临界区

+ 互斥量
    * 概念：互斥锁是一个特殊的变量，它具有 **锁上** 和 **打开** 两个状态。打开的互斥锁可以被某个线程获得。一旦获得，这个互斥锁就会锁上，此后只有该线程有权打开。其他想要获得该互斥锁的线程会一直等待
    * 接口：mutex_lock()与mutex_unlock()

+ 条件变量
    * 概念：如果某个线程正在等待共享数据内某个条件的出现，采用互斥量的做法可能需要重复对数据进行加锁、查询和解锁，这样非常浪费时间和资源，而且效率低。条件变量可以解决这一问题。当线程在某一条件未满足的时候进入睡眠状态，一旦此条件满足，就唤醒等待该条件的线程
    * 接口：cond_wait()和cond_signal()/cond_broadcast()

+ 读写锁
    * 概念：读写锁具有三种状态：共享读取锁，互斥写入锁和打开。如果一个线程获得读取锁，则其他线程可以继续获得读取锁；但是如果有其他线程想要获得写入锁，则必须等待持有读取锁的线程释放掉自己的读取锁。如果一个线程获得写入锁，那么其他线程无论是想获取读取锁还是想获取写入锁，都必须等待该线程释放写入锁。

+ 信号量
    * 概念：为控制一个具有有限数量用户资源而设计的。
        - 如果当前资源的数量大于0，则信号量有效
        - 如果当前资源的数量是0，则信号量无效
        - 系统不允许当前资源的数量为负值
        - 当前资源数量决不能大于最大资源数量
    * 接口：创建信号量CreateSemaphore函数，释放信号量ReleaseSemaphore函数